# Optimisation with an ecology penalty in the Pentland Firth
# ==========================================================
#
#
# Introduction
# ************
#
# This example demonstrates how OpenTidalFarm can be used to integrate
# ecological penalties into the optimisation process.
#
# It shows how to:
#   - load a mesh from file;
#   - use realistic tidal forcing on the open boundaries;
#   - load the bathymetry from a NetCDF file;
#   - use a non-homogenous viscosity;
#   - solve a time-dependent shallow water solver and store the results to file.
#
# We will be simulating the tides in the Pentland Firth, Scotland for 12.5
# hours, starting at 14:40 am on the 18.9.2001. The flow result at the end of
# the simulation looks like:
#
# .. image:: flow.png
#     :scale: 80
#
# This example requires some large data files, that must be downloaded
# separately by calling in the source code directory:
#
# .. code-block:: bash
#
#    git submodule init
#    git submodule update


# Implementation
# **************

# We begin with importing the OpenTidalFarm module.


from opentidalfarm import *
from model_turbine import ModelTurbine
set_log_level(INFO)

model_turbine = ModelTurbine()
print model_turbine

# First we define the computational domain. We load a previously generated mesh
# (using ```Gmsh``` and converted with ```dolfin-convert```):

domain = FileDomain('mesh_coarse/coast.xml')

# Next we get the default parameters of a shallow water problem and configure it
# to our needs.

prob_params = SteadySWProblem.default_parameters()

# Once the domain is created we attach it to the problem parameters:

prob_params.domain = domain

# Next we input the location of the eco domain,
# these coordinates cover the south coast of Stroma

eco_x_start = 492000
eco_y_start = 6503000
eco_x_end = eco_x_start + 2000
eco_y_end = eco_y_start + 1000

# we use the coordinates to define the eco-domain as a subdomain

class EcoDomain(SubDomain):
    def inside(self, x, on_boundary):
        return (eco_x_start <= x[0] <= eco_x_end and
                eco_y_start <= x[1] <= eco_y_end)
eco_domain = EcoDomain()

# Next we load the bathymetry from the NetCDF file.

V = FunctionSpace(domain.mesh, 'CG', 1)
depth = Function(V, name="depth")
File("mesh_coarse/bathymetry.xml") >> depth
prob_params.depth = depth

# The bathymetry can be visualised with

#plot(bathy_expr, mesh=domain.mesh, title="Bathymetry", interactive=True)

# For stability reasons, we want to increase the viscosity at the inflow and
# outflow boundary conditions. For that, we read in a precomputed function
# (generated by ```compute_distance```)

dist = Function(V)
File("dist.xml") >> dist

# With that we can define an expression that evaluates to a nu_inside value
# inside the domain and a nu_outside value near the in/outflow boundary.

class ViscosityExpression(Expression):
    def __init__(self, dist_function, dist_threshold, nu_inside, nu_boundary):
        self.dist_function = dist_function
        self.nu_inside = nu_inside
        self.nu_boundary = nu_boundary
        self.dist_threshold = dist_threshold

    def eval(self, value, x):
        if self.dist_function(x) > self.dist_threshold:
            value[0] = self.nu_inside
        else:
            value[0] = self.nu_boundary

# Finally, we interpolate this expression to a piecewise discontinuous, constant
# function and attach it as the viscosity value to the shallow water problem.

W = FunctionSpace(domain.mesh, "DG", 0)
nu = ViscosityExpression(dist, dist_threshold=1000, nu_inside=115.,
                         nu_boundary=1e3)
nu_func = interpolate(nu, W)
prob_params.viscosity = nu_func

# create the farm and the necessary subdomains

turbine = SmearedTurbine()
U = FunctionSpace(domain.mesh, "DG", 0)
farm = Farm(domain, turbine, function_space=U)

domains = MeshFunction("size_t", domain.mesh, "mesh_coarse/coast_physical_region.xml")

eco_domain.mark(domains, 3)
dx = Measure("dx")[domains]
farm.site_dx = dx(2)
prob_params.eco_dx = dx(3)

prob_params.tidal_farm = farm

# Next we specify the boundary conditions.  The parameter `t` in the
# :class:`dolfin.Expression` is special in OpenTidalFarm as it will be
# automatically updated to the current timelevel during the solve.

bcs = BoundaryConditionSet()
bcs.add_bc("u", Constant((2, 0)), facet_id=1)
bcs.add_bc("eta", Constant(0), facet_id=1)
bcs.add_bc("eta", Constant(0), facet_id=2)

# The free-slip boundary conditions are a special case. The boundary condition
# type `weak_dirichlet` enforces the boundary value *only* in the *normal*
# direction of the boundary. Hence, a zero weak Dirichlet boundary condition
# gives us free-slip, while a zero `strong_dirichlet` boundary condition would
# give us no-slip.

bcs.add_bc("u", Constant((0, 0)), facet_id=3, bctype="strong_dirichlet")

# Again we attach boundary conditions to the problem parameters:

prob_params.bcs = bcs

# Equation settings
prob_params.friction = Constant(0.0025)
prob_params.eco_penalty_multiplier = 3000
# The initial condition consists of three components: u_x, u_y and eta
# Note that we do not set all components to zero, as some components of the
# Jacobian of the quadratic friction term is non-differentiable.
prob_params.initial_condition = Expression(("1e-7", "0", "0"))

# Once the parameter have been set, we create the shallow water problem:

problem = SteadySWProblem(prob_params)

# Next we create a shallow water solver. Here we choose to solve the shallow
# water equations in its fully coupled form. Again, we first ask for the default
# parameters, adjust them to our needs and then create the solver object.

sol_params = CoupledSWSolver.default_parameters()
sol_params.dump_period = 1
sol_params.cache_forward_state = False
solver = CoupledSWSolver(problem, sol_params)

# read in ambient flow
Vamb = VectorFunctionSpace(domain.mesh, 'CG', 1, dim=2)
u_ambient = list()
u_ambient.append(Function(Vamb,'ambient.xml'))

# define the functional
functional = PowerFunctional(problem) - 4800*CostFunctional(problem) \
   - EcologyFunctional(problem, solver, u_ambient)

# Define the control
control = TurbineFarmControl(farm)

# Set up the reduced functional
rf_params = ReducedFunctional.default_parameters()
rf_params.automatic_scaling = None
rf = ReducedFunctional(functional, control, solver, rf_params)

# As always, we can print all options of the :class:`ReducedFunctional` with:

print rf_params

# Now we can start the optimisation.

f_opt = maximize(rf, bounds=[0, model_turbine.maximum_smeared_friction],
                 method="L-BFGS-B", options={'maxiter': 30})
